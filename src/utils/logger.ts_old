
import { Worker, isMainThread, parentPort, workerData } from 'worker_threads';
import os from 'os';
import fs from 'fs';
import path from 'path';
import zlib from 'zlib';
import type { LogLevel } from './config/types';

type FileType = 'page' | 'layout' | 'server' | 'api' | 'store' | 'util' | 'other';

const COLORS: Record<LogLevel, string> = {
    debug: '\x1b[34m',
    info: '\x1b[32m',
    warn: '\x1b[33m',
    error: '\x1b[31m',
    none: '\x1b[0m'
};

const FILE_TYPE_PREFIXES: Record<FileType, string> = {
    page: '[PAGE]',
    layout: '[LAYOUT]',
    server: '[SERVER]',
    api: '[API]',
    store: '[STORE]',
    util: '[UTIL]',
    other: '[OTHER]'
};

const MAX_LOG_SIZE = 5 * 1024 * 1024; // 5 MB
const LOG_DIRECTORY = path.resolve('logs');

if (!fs.existsSync(LOG_DIRECTORY)) {
    fs.mkdirSync(LOG_DIRECTORY);
}

const fastJsonStringify = (function() {
    const cache = new WeakSet();
    return function(obj: any): string {
        return JSON.stringify(obj, (key, value) => {
            if (typeof value === 'object' && value !== null) {
                if (cache.has(value)) {
                    return '[Circular]';
                }
                cache.add(value);
            } else if (value instanceof Error) {
                return {
                    type: 'Error',
                    message: value.message,
                    stack: value.stack
                };
            }
            return value;
        });
    };
})();

class Logger {
    private logLevels: Set<LogLevel>;
    private workers: Worker[];
    private nextWorker: number = 0;
    private isProduction: boolean;

    constructor(isProduction = false, logLevels: LogLevel[]) {
        this.logLevels = new Set(logLevels);
        this.workers = [];
        this.isProduction = isProduction;
        if (!this.isProduction) {
            this.initializeWorkers();
        }
    }

    private initializeWorkers() {
        const numWorkers = os.cpus().length;
        for (let i = 0; i < numWorkers; i++) {
            const worker = new Worker(__filename, {
                workerData: { workerId: i }
            });
            this.workers.push(worker);
        }
    }

    private logLevelEnabled(level: LogLevel): boolean {
        return this.logLevels.has(level);
    }

    private formatMessage(level: LogLevel, message: string, fileType: FileType, context?: Record<string, any>): string {
        const logObject = {
            time: Date.now(),
            level: level,
            fileType: FILE_TYPE_PREFIXES[fileType],
            msg: message,
            ...context
        };
        return fastJsonStringify(logObject);
    }

    private log(level: LogLevel, message: string, fileType: FileType, context?: Record<string, any>) {
        if (this.isProduction || !this.logLevelEnabled(level)) return;

        const formattedMessage = this.formatMessage(level, message, fileType, context);
        this.sendToWorker(level, formattedMessage);
    }

    private sendToWorker(level: LogLevel, message: string) {
        const worker = this.workers[this.nextWorker];
        this.nextWorker = (this.nextWorker + 1) % this.workers.length;
        worker.postMessage({ level, message });
    }

    debug(message: string, fileType: FileType, context?: Record<string, any>) {
        this.log('debug', message, fileType, context);
    }

    info(message: string, fileType: FileType, context?: Record<string, any>) {
        this.log('info', message, fileType, context);
    }

    warn(message: string, fileType: FileType, context?: Record<string, any>) {
        this.log('warn', message, fileType, context);
    }

    error(message: string, fileType: FileType, error?: Error, context?: Record<string, any>) {
        const errorContext = error ? { error } : {};
        this.log('error', message, fileType, { ...errorContext, ...context });
    }

    setLogLevels(levels: LogLevel[]) {
        this.logLevels = new Set(levels);
        if (levels.length === 1 && levels[0] === 'none') {
            this.isProduction = true;
            this.workers.forEach(worker => worker.terminate());
            this.workers = [];
        }
    }

    updateConfig(config: { logLevels?: LogLevel[], maxLogSize?: number, isProduction?: boolean }) {
        if (config.logLevels) {
            this.setLogLevels(config.logLevels);
        }
        if (config.maxLogSize) {
            this.workers.forEach(worker => worker.postMessage({ type: 'updateConfig', config: { maxLogSize: config.maxLogSize } }));
        }
        if (config.isProduction !== undefined) {
            this.isProduction = config.isProduction;
            if (this.isProduction) {
                this.workers.forEach(worker => worker.terminate());
                this.workers = [];
            } else {
                this.initializeWorkers();
            }
        }
    }
}

// Helper function to determine file type
function getFileType(fileName: string): FileType {
    if (fileName.endsWith('.svelte')) return 'page';
    if (fileName.endsWith('.ts') || fileName.endsWith('.js')) {
        if (fileName.includes('+page.server')) return 'server';
        if (fileName.includes('api')) return 'api';
        if (fileName.includes('store')) return 'store';
        if (fileName.includes('util')) return 'util';
    }
    return 'other';
}

// Create logger instance
import { publicEnv } from '../config/public';

const logger = new Logger(process.env.NODE_ENV === 'production', publicEnv.LOG_LEVELS);

// Export createLogger function
export function createLogger(fileName: string) {
    const fileType = getFileType(fileName);
    return {
        debug: (message: string, context?: Record<string, any>) => logger.debug(message, fileType, context),
        info: (message: string, context?: Record<string, any>) => logger.info(message, fileType, context),
        warn: (message: string, context?: Record<string, any>) => logger.warn(message, fileType, context),
        error: (message: string, error?: Error, context?: Record<string, any>) => logger.error(message, fileType, error, context)
    };
}

export { logger };

// Worker thread code
if (!isMainThread) {
    let maxLogSize = MAX_LOG_SIZE;
    const logFiles: Record<LogLevel, string> = {
        debug: 'debug.log',
        info: 'info.log',
        warn: 'warn.log',
        error: 'error.log',
        none: ''
    };

    const streams: Record<LogLevel, fs.WriteStream> = {
        debug: fs.createWriteStream(path.join(LOG_DIRECTORY, logFiles.debug), { flags: 'a' }),
        info: fs.createWriteStream(path.join(LOG_DIRECTORY, logFiles.info), { flags: 'a' }),
        warn: fs.createWriteStream(path.join(LOG_DIRECTORY, logFiles.warn), { flags: 'a' }),
        error: fs.createWriteStream(path.join(LOG_DIRECTORY, logFiles.error), { flags: 'a' }),
        none: null
    };

    parentPort.on('message', async (message: { level: LogLevel, message: string, type?: string, config?: any }) => {
        if (message.type === 'updateConfig') {
            if (message.config.maxLogSize) {
                maxLogSize = message.config.maxLogSize;
            }
            return;
        }

        const { level, message: logMessage } = message;
        if (!streams[level]) return;

        await checkAndRotateLogFile(level);
        streams[level].write(logMessage + '\n');

        const consoleMessage = `${COLORS[level]}${logMessage}\x1b[0m`;
        console[level](consoleMessage);
    });

    async function checkAndRotateLogFile(level: LogLevel) {
        const filePath = path.join(LOG_DIRECTORY, logFiles[level]);
        const stats = await fs.promises.stat(filePath).catch(() => null);

        if (stats && stats.size > maxLogSize) {
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
            const compressedFilePath = `${filePath}.${timestamp}.gz`;

            await new Promise<void>(resolve => streams[level].end(resolve));

            const gzip = zlib.createGzip();
            const source = fs.createReadStream(filePath);
            const destination = fs.createWriteStream(compressedFilePath);

            await new Promise((resolve, reject) => {
                source.pipe(gzip).pipe(destination)
                    .on('finish', resolve)
                    .on('error', reject);
            });

            await fs.promises.unlink(filePath);
            streams[level] = fs.createWriteStream(filePath, { flags: 'a' });
        }
    }
}